<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="author" content="McFog Wang">
  <meta name="generator" content="Hugo 0.69.2" />
  

  <title>McFog＠がんばらない</title>
  <link rel="canonical" href="http://press.mcfog.wang/2013/06/an-elegant-design-to-unify-async-and-sync-callback-based-on-promise-object/"/> 
  <link rel="stylesheet" href="//cdn.jsdelivr.net/g/github-markdown-css@2.2.1,highlight.js@9.2.0(styles/github.min.css)" />
  <link rel="alternate" href="/index.xml" title="McFog＠がんばらない" type="application/atom+xml">  
  <link rel="stylesheet" href="/css/style.css" />
</head>
<body>

<header class="container">
  <h1>
    <a href="/">
      <span id="slogan_shadow">McFog＠がんばらない</span>
      <span id="slogan"></span>
    </a>  
  </h1>
</header>



<div class="main container">

<article class="prepost post-header box">
  <div class="thumb" style="background-image: url(/2013/06/an-elegant-design-to-unify-async-and-sync-callback-based-on-promise-object/promise.jpg)"></div>
  <h4>
      <a>
          An elegant design to unify async and sync callback based on promise object
      </a>
  </h4>
  <h5>2013-06-09</h5>
</article>

<article class="post box">

<div class="thumb" style="background-image: url(/2013/06/an-elegant-design-to-unify-async-and-sync-callback-based-on-promise-object/promise.jpg)"></div>

<section class="post-header">
    <h4>
        <a href="http://press.mcfog.wang/2013/06/an-elegant-design-to-unify-async-and-sync-callback-based-on-promise-object/">
            An elegant design to unify async and sync callback based on promise object
        </a>
    </h4>
    <h5>2013-06-09</h5>
</section>


<section class="content markdown-body"><p>在JS代码的设计中，“回调”是非常重要而有效的手段，这里讨论的是框架需要获取回调结果的，更加注重IoC的回调。（另一种回调的使用往往更接近订阅者模式，强调信息的单向下发）往往框架代码需要获取某些信息，但如何获取的逻辑需要留待使用者实现，此时回调就是非常直接的选择。</p>
<p>获取回调的输出信息有最直接的使用返回值（同步），但异步有时是无法避免的。本文不准备讨论设计回调时应该设计成同步返回还是异步返回，而是讨论如何简洁而优雅地兼容两者，使回调既能够直接返回结果，又可以通知框架等待异步返回结果。</p>
<p>在JS中，可以和回调交互的地方一共有3个，分别是<code>this</code>对象、参数(<code>arguments</code>)和返回值。我们先看看利用this和arguments来实现的兼容同步异步的大致做法，再来看看利用返回值并引入deferred机制后对代码的提升。</p>
<h3 id="替换this">替换this</h3>
<p><a href="http://layoutmanager.org">backbone layoutmanager</a>中采用了替换<code>this</code>对象的方式实现兼容同步和异步的模板获取/渲染。好处是业务代码看起来相对清晰，但由于替换掉了this，比较依赖this的逻辑会碰到麻烦。另外实现相对复杂</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">//同步回调
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fetchSync</span>(<span style="color:#a6e22e">path</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_</span>.<span style="color:#a6e22e">template</span>(<span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">path</span>).<span style="color:#a6e22e">html</span>());
}
<span style="color:#75715e">//异步回调
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fetchAsync</span>(<span style="color:#a6e22e">path</span>) {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">done</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">async</span>();

  <span style="color:#a6e22e">$</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">path</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">contents</span>) {
    <span style="color:#a6e22e">done</span>(<span style="color:#a6e22e">_</span>.<span style="color:#a6e22e">template</span>(<span style="color:#a6e22e">contents</span>));
  }, <span style="color:#e6db74">&#34;text&#34;</span>);
}
</code></pre></div><p>大致框架实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">makeAsync</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">done</span>) {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> {};
    <span style="color:#a6e22e">handler</span>.<span style="color:#a6e22e">async</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>() {
        <span style="color:#a6e22e">handler</span>.<span style="color:#a6e22e">_isAsync</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">done</span>;
    }

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">handler</span>;
}

<span style="color:#a6e22e">exports</span>.<span style="color:#a6e22e">AwesomeFunction</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">callback</span>) {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">done</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">result</span>) {
        <span style="color:#75715e">//handle result
</span><span style="color:#75715e"></span>    };
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">handler</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">makeAsync</span>(<span style="color:#a6e22e">done</span>);
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">callback</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">handler</span>, <span style="color:#a6e22e">path</span>);
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">handler</span>.<span style="color:#a6e22e">_isAsync</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">done</span>(<span style="color:#a6e22e">result</span>);
}
</code></pre></div><p>可以发现为了制造出this对象以及判断是否异步的逻辑比较生硬，另外替换掉this的做法不是所有场景都可以接受。回调和框架的耦合也比较强，离开了框架的话回调由于有<code>done=this.async()</code>基本没法用。</p>
<h3 id="追加arguments">追加arguments</h3>
<p>对参数动手脚来实现异步/同步兼容的话，一般选择在参数列表最前/最后追加 <em>回调的回调</em> 用来和框架交换数据。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">//同步回调
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fetchSync</span>(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">done</span>) {
  <span style="color:#a6e22e">done</span>(<span style="color:#a6e22e">_</span>.<span style="color:#a6e22e">template</span>(<span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">path</span>).<span style="color:#a6e22e">html</span>()));
}
<span style="color:#75715e">//异步回调
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fetchAsync</span>(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">done</span>) {
  <span style="color:#a6e22e">$</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">path</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">contents</span>) {
    <span style="color:#a6e22e">done</span>(<span style="color:#a6e22e">_</span>.<span style="color:#a6e22e">template</span>(<span style="color:#a6e22e">contents</span>));
  }, <span style="color:#e6db74">&#34;text&#34;</span>);
}
</code></pre></div><p>大致框架实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">exports</span>.<span style="color:#a6e22e">AwesomeFunction</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">callback</span>) {
    <span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">path</span>, <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">result</span>) {
        <span style="color:#75715e">//handle result
</span><span style="color:#75715e"></span>    });
}
</code></pre></div><p>比起上一种方法，这种方法的优点是实现简洁明了，如果需要可以保持this，缺点是需要改变函数签名，对签名不定长的情形比较恶心。另外，同步返回的回调不能简单地return返回值也是比较严重的缺点。</p>
<h3 id="__利用返回值和deferred机制__"><strong>利用返回值和deferred机制</strong></h3>
<p><a href="http://wiki.commonjs.org/wiki/Promises/A">deferred/promise机制</a>天生对回调非常友好，只要定义回调返回普通值=同步，返回promise=异步，就可以很优雅地做到兼容同步和异步。所需的仅仅是一个简单的包装器<code>isPromise(foo) ? foo : makePromise(foo)</code>的实现。这里以jQuery为例，<code>jQuery.when</code>就是一个不错的包装器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">//同步
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fetchSync</span>(<span style="color:#a6e22e">path</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_</span>.<span style="color:#a6e22e">template</span>(<span style="color:#a6e22e">$</span>(<span style="color:#a6e22e">path</span>).<span style="color:#a6e22e">html</span>());
}
<span style="color:#75715e">//异步
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fetchAsync</span>(<span style="color:#a6e22e">path</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">$</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">path</span>, <span style="color:#e6db74">&#34;text&#34;</span>).<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">contents</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_</span>.<span style="color:#a6e22e">template</span>(<span style="color:#a6e22e">contents</span>);
  });
}
</code></pre></div><p>大致框架实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">exports</span>.<span style="color:#a6e22e">AwesomeFunction</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">path</span>, <span style="color:#a6e22e">callback</span>) {
    <span style="color:#a6e22e">$</span>.<span style="color:#a6e22e">when</span>(<span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">path</span>)).<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">result</span>) {
        <span style="color:#75715e">//handle result
</span><span style="color:#75715e"></span>    }, <span style="color:#66d9ef">function</span>() {
        <span style="color:#75715e">//handle error
</span><span style="color:#75715e"></span>    });
}
</code></pre></div><p>利用返回值的好处在于完整保留了<code>this</code>和<code>arguments</code>，同步的情形下无论回调依赖this还是参数都无需包装回调，而异步的情况下，返回promise的回调的适用范围要比前两种机制的回调广泛的多。另外promise天生比较完备的错误处理，<code>jQuery.when</code>对多个参数的支持都使得这种方法在实践中具备很强的可操作性。</p>
<h3 id="举一反三">举一反三……</h3>
<p>无论是设计框架还是切分方法，对于“异步获取信息”的情景来说，返回一个发布者(promise)比接受回调要更加灵活。</p>
<ul>
<li>接受回调会影响方法签名，而且通常浪费了返回值，返回发布者对象对整体程序的语义有很大地提升（参数=输入，返回值=输出）</li>
<li>接受回调限定了订阅者的数量为1（兼容0和多个都需要不少兼容逻辑），而发布者通常不关心订阅者的数量</li>
<li>接受回调要求调用方在调用时就准备好所有的订阅者，无法追加订阅者，而发布者不仅可以很容易地追加订阅者，其本身作为一个对象还可以被传递</li>
<li>发布者可以有更灵活的方法来处理嵌套、并发以及异常等各种情况</li>
</ul>
<p>&ndash;EOF&ndash;</p></section>

</article>


  <div class="row">
    
      <article class="six columns post-header box">
  <div class="thumb" style="background-image: url(/2013/06/dsl-style-javascript-design/form.jpg)"></div>
  <h4>
      <a href="http://press.mcfog.wang/2013/06/dsl-style-javascript-design/">
          DSL style javascript design
      </a>
  </h4>
  <h5>2013-06-03</h5>
</article>

    
    
      <article class="six columns post-header box">
  <div class="thumb" style="background-image: url(/2013/06/undocumented-stylus-built-in-functions/stylus.jpg)"></div>
  <h4>
      <a href="http://press.mcfog.wang/2013/06/undocumented-stylus-built-in-functions/">
          Undocumented stylus built-in functions
      </a>
  </h4>
  <h5>2013-06-14</h5>
</article>

    
  </div>
</div>




<div class="container copy">
  &copy; 2020 McFog W. All rights reserved. 
  <small>がんばらない</small>
</div>
<script src="//cdn.jsdelivr.net/g/theaterjs@2.0.1,highlight.js@9.2.0" data-no-instant></script>
<script data-no-instant>
  (function() {
    theaterJS()
      .addActor('slogan', {speed: 0.5, accuracy: 1})
      .addScene(500, 'slogan:', 'McFog', 400, '＠がん', 100, 'ばらない');

    hljs.initHighlightingOnLoad();
  })();
</script>
</body>
</html>
